<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Futuristic Minimalism â€” Hero</title>
<meta name="color-scheme" content="dark" />
<meta name="description" content="Sleek futuristic hero section with neon accents, floating 3D shapes, soft glow headline, and smooth animations." />
<style>
  :root{
    --bg-0: #060a13;
    --bg-1: #0a0f1b;
    --bg-2: #0c1120;
    --neon-a: #00d9ff;  /* cyan-blue */
    --neon-b: #7c3fff;  /* violet */
    --neon-c: #12ffe3;  /* teal accent */
    --text:   #e9f1ff;
    --muted:  #9fb1c7;
    --glass: rgba(255,255,255,0.06);
    --glass-2: rgba(255,255,255,0.035);
    --shadow: rgba(0,0,0,0.5);
    --radius: 14px;
    --ease-1: cubic-bezier(.2,.7,.2,1);
    --ease-2: cubic-bezier(.16, 1, .3, 1);
  }

  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body{
    margin: 0;
    color: var(--text);
    font-family: Inter, ui-sans-serif, system-ui, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    background:
      radial-gradient(1200px 600px at 10% 10%, rgba(124,63,255,.18) 0%, transparent 55%),
      radial-gradient(1100px 600px at 90% 15%, rgba(0,217,255,.18) 0%, transparent 55%),
      linear-gradient(180deg, var(--bg-1), var(--bg-0) 60%, var(--bg-2) 100%);
    overflow-x: hidden;
  }

  /* Subtle grid/scanlines overlay for tech vibe */
  .bg-overlay::before,
  .bg-overlay::after{
    content:"";
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 0;
  }
  .bg-overlay::before{
    background:
      linear-gradient(transparent 29px, rgba(255,255,255,.025) 30px),
      linear-gradient(90deg, transparent 29px, rgba(255,255,255,.025) 30px);
    background-size: 30px 30px;
    opacity: .35;
    mix-blend-mode: overlay;
  }
  .bg-overlay::after{
    background: radial-gradient(1200px 1200px at 50% 10%, rgba(124,63,255,.06), transparent 55%),
                radial-gradient(1200px 1200px at 50% 80%, rgba(0,217,255,.05), transparent 55%);
    filter: blur(2px);
    opacity: .8;
  }

  header.nav{
    position: fixed;
    top: 0; left: 0; right: 0;
    height: 68px;
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: center;
    gap: 16px;
    padding: 0 clamp(16px, 5vw, 40px);
    z-index: 10;
    backdrop-filter: saturate(120%) blur(10px);
    background: linear-gradient(180deg, rgba(10,16,27,.6), rgba(10,16,27,.3));
    border-bottom: 1px solid rgba(255,255,255,.06);
  }
  .brand{
    display: flex; align-items: center; gap: 12px;
    font-weight: 700; letter-spacing: .12em; text-transform: uppercase;
  }
  .brand .logo{
    width: 28px; height: 28px; display: grid; place-items: center;
    border-radius: 8px;
    background: radial-gradient(100% 100% at 30% 30%, rgba(124,63,255,.6), rgba(0,217,255,.4) 70%);
    box-shadow: 0 0 20px rgba(124,63,255,.6), inset 0 0 16px rgba(0,217,255,.35);
    border: 1px solid rgba(255,255,255,.12);
  }
  nav.links{
    justify-self: center;
    display: flex; gap: clamp(10px, 4vw, 28px);
  }
  nav.links a{
    color: var(--muted); text-decoration: none; font-size: .95rem;
    padding: 8px 10px; border-radius: 10px;
    transition: color .25s var(--ease-1), background-color .25s var(--ease-1), transform .25s var(--ease-1);
  }
  nav.links a:hover{
    color: var(--text);
    background-color: var(--glass-2);
    transform: translateY(-1px);
  }
  .nav-cta{
    justify-self: end;
    display: flex; gap: 12px; align-items: center;
  }

  .btn{
    position: relative;
    display: inline-flex; align-items: center; justify-content: center;
    gap: 10px;
    border-radius: 999px;
    padding: 12px 18px;
    font-weight: 600;
    letter-spacing: .04em;
    text-decoration: none;
    cursor: pointer;
    border: 1px solid rgba(255,255,255,.14);
    color: var(--text);
    transition: transform .35s var(--ease-2), box-shadow .35s var(--ease-2), background .35s var(--ease-2), border-color .35s var(--ease-2);
    will-change: transform;
  }
  .btn.primary{
    background: linear-gradient(135deg, rgba(0,217,255,.2), rgba(124,63,255,.18));
    box-shadow: 0 0 0 0 rgba(124,63,255,0);
  }
  .btn.primary:hover{
    transform: translateY(-2px) scale(1.02);
    border-color: rgba(255,255,255,.22);
    box-shadow: 0 12px 30px -10px rgba(0,217,255,.35), 0 10px 40px -16px rgba(124,63,255,.45), inset 0 0 18px rgba(0,217,255,.2);
  }
  .btn.ghost{
    background: transparent;
  }
  .btn.ghost:hover{
    background: var(--glass-2);
    transform: translateY(-2px);
    box-shadow: 0 12px 30px -16px rgba(0,0,0,.6), inset 0 0 0 1px rgba(255,255,255,.05);
  }

  section.hero{
    position: relative; min-height: 100svh; display: grid; place-items: center;
    padding: clamp(80px, 12vh, 160px) clamp(16px, 5vw, 64px);
    isolation: isolate;
  }
  /* Canvas background for 3D shapes */
  #bg{
    position: absolute; inset: 0; width: 100%; height: 100%;
    z-index: 0; display: block;
  }

  /* Subtle gradient glows behind content */
  .glows{
    position: absolute; inset: 0; z-index: 1; pointer-events: none;
  }
  .glows::before, .glows::after{
    content:""; position: absolute; width: 60vmax; height: 60vmax;
    filter: blur(60px); opacity: .35; transform: translate(-20%, -20%);
    background: radial-gradient(circle at 50% 50%, rgba(124,63,255,.35), transparent 60%);
  }
  .glows::after{
    right: -15%; bottom: -15%; left: auto; top: auto;
    background: radial-gradient(circle at 50% 50%, rgba(0,217,255,.35), transparent 60%);
    transform: translate(15%, 15%);
  }

  .hero-content{
    position: relative; z-index: 2;
    max-width: 1100px; width: 100%;
    display: grid; gap: 22px; text-align: center;
    padding: clamp(12px, 2vw, 20px);
  }
  .eyebrow{
    display: inline-flex; align-self: center; justify-self: center;
    gap: 10px; align-items: center;
    font-size: .85rem; letter-spacing: .16em; text-transform: uppercase;
    color: var(--muted);
    background: rgba(255,255,255,.04);
    border: 1px solid rgba(255,255,255,.1);
    padding: 8px 12px; border-radius: 999px;
    backdrop-filter: blur(6px) saturate(120%);
  }
  .eyebrow .dot{
    width: 8px; height: 8px; border-radius: 50%;
    background: radial-gradient(circle, var(--neon-a), var(--neon-b));
    box-shadow: 0 0 10px var(--neon-a), 0 0 16px var(--neon-b);
  }

  h1.hero-title{
    margin: 0;
    font-size: clamp(2.4rem, 6vw + 1rem, 5.8rem);
    line-height: 1.02;
    letter-spacing: .01em;
    background: linear-gradient(90deg, #fdfcff 0%, #d6eaff 40%, #e8ddff 60%, #fdfcff 100%);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    text-shadow:
      0 0 12px rgba(0,217,255,.18),
      0 0 24px rgba(124,63,255,.2);
  }
  .sub{
    font-size: clamp(1rem, 1.2vw + .6rem, 1.35rem);
    color: var(--muted);
    max-width: 820px;
    margin: 0 auto;
  }
  .cta-row{
    display: flex; gap: 14px; justify-content: center; align-items: center;
    margin-top: 6px;
  }

  .chip{
    display: inline-flex; align-items: center; gap: 8px;
    padding: 8px 12px; border-radius: 999px;
    border: 1px dashed rgba(255,255,255,.12);
    color: var(--muted);
    font-size: .85rem;
    background: rgba(255,255,255,.02);
  }
  .chip .pulse{
    position: relative;
    width: 10px; height: 10px; border-radius: 50%;
    background: var(--neon-a);
    box-shadow: 0 0 10px var(--neon-a), 0 0 22px var(--neon-a);
  }
  .chip .pulse::after{
    content: ""; position: absolute; inset: -6px;
    border-radius: inherit;
    border: 2px solid rgba(0,217,255,.4);
    animation: pulse 2.2s infinite;
  }
  @keyframes pulse{
    0% { transform: scale(.6); opacity: .8; }
    70% { transform: scale(1.2); opacity: 0; }
    100% { transform: scale(1.2); opacity: 0; }
  }

  /* Scroll indicator */
  .scroll-indicator{
    position: absolute; left: 50%; bottom: 24px; transform: translateX(-50%);
    width: 26px; height: 46px; border-radius: 16px;
    border: 1px solid rgba(255,255,255,.18);
    background: rgba(255,255,255,.02);
    display: grid; place-items: start center;
    overflow: hidden; z-index: 3;
  }
  .scroll-indicator::after{
    content:""; width: 6px; height: 10px; margin-top: 8px; border-radius: 4px;
    background: radial-gradient(circle at 50% 0%, var(--neon-b), var(--neon-a));
    animation: wheel 2.6s var(--ease-1) infinite;
    box-shadow: 0 0 10px rgba(124,63,255,.6), 0 0 16px rgba(0,217,255,.5);
  }
  @keyframes wheel{
    0%{ transform: translateY(0); opacity: 1; }
    70%{ transform: translateY(18px); opacity: .2; }
    100%{ transform: translateY(18px); opacity: 0; }
  }

  /* Reveal on scroll */
  .reveal{ opacity: 0; transform: translateY(16px); transition: opacity .7s var(--ease-1), transform .7s var(--ease-1); }
  .reveal.in{ opacity: 1; transform: translateY(0); }

  /* Example content below hero to demonstrate fade-in on scroll */
  section.features{
    position: relative; z-index: 2;
    padding: 80px clamp(16px, 6vw, 80px) 120px;
    display: grid; gap: 28px; max-width: 1100px; margin: 0 auto;
  }
  .cards{
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    gap: 18px;
  }
  .card{
    position: relative;
    padding: 22px;
    background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    border: 1px solid rgba(255,255,255,.08);
    border-radius: var(--radius);
    box-shadow: 0 8px 24px -12px var(--shadow);
    overflow: hidden;
    transition: transform .35s var(--ease-2), box-shadow .35s var(--ease-2), border-color .35s var(--ease-2);
  }
  .card:hover{
    transform: translateY(-4px);
    border-color: rgba(255,255,255,.16);
    box-shadow: 0 16px 40px -14px rgba(0,217,255,.18), 0 24px 60px -30px rgba(124,63,255,.22);
  }
  .card .accent{
    position: absolute; inset: 0; pointer-events: none;
    background: radial-gradient(400px 200px at var(--mx,50%) var(--my,50%), rgba(0,217,255,.1), transparent 60%),
                radial-gradient(400px 200px at calc(var(--mx,50%) + 12%) calc(var(--my,50%) + 4%), rgba(124,63,255,.1), transparent 60%);
    opacity: 0; transition: opacity .35s var(--ease-2);
  }
  .card:hover .accent{ opacity: 1; }

  @media (prefers-reduced-motion: reduce){
    .btn, .card, .reveal, .scroll-indicator::after { transition: none !important; animation: none !important; }
  }
</style>
</head>
<body>
  <div class="bg-overlay"></div>

  <header class="nav reveal">
    <div class="brand">
      <div class="logo">â—†</div>
      <span>NOVA</span>
    </div>
    <nav class="links">
      <a href="#work">Work</a>
      <a href="#about">About</a>
      <a href="#contact">Contact</a>
    </nav>
    <div class="nav-cta">
      <a class="btn ghost" href="#signin">Sign in</a>
      <a class="btn primary" href="#get-started">Get started</a>
    </div>
  </header>

  <section class="hero">
    <!-- Interactive Canvas Background -->
    <canvas id="bg" aria-hidden="true"></canvas>
    <div class="glows" aria-hidden="true"></div>

    <div class="hero-content">
      <div class="eyebrow reveal">
        <span class="dot"></span> Futuristic Minimalism
      </div>

      <h1 class="hero-title reveal">
        A sleek interface for the next frontier
      </h1>

      <p class="sub reveal">
        Dark canvas. Neon accents. Floating geometry. Experience an ultra-modern tech vibe with subtle motion and graceful interactions.
      </p>

      <div class="cta-row reveal">
        <a class="btn primary" href="#explore">
          Explore the demo
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M7 17L17 7" stroke="url(#g1)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M9 7h8v8" stroke="url(#g1)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <defs><linearGradient id="g1" x1="7" y1="17" x2="17" y2="7"><stop stop-color="#00D9FF"/><stop offset="1" stop-color="#7C3FFF"/></linearGradient></defs>
          </svg>
        </a>
        <a class="btn ghost" href="#learn">Learn more</a>
      </div>

      <div class="chip reveal" style="justify-self:center; margin-top: 8px;">
        <span class="pulse" aria-hidden="true"></span>
        Smooth fade-in on scroll
      </div>
    </div>

    <div class="scroll-indicator" aria-hidden="true"></div>
  </section>

  <section class="features" id="work">
    <h2 class="reveal" style="margin:0; font-size: clamp(1.6rem, 1.4vw + 1rem, 2.2rem); letter-spacing: .01em;">
      Crafted for clarity and motion
    </h2>
    <p class="reveal" style="margin:0; color: var(--muted); max-width: 760px;">
      Below are sample cards to demonstrate the subtle hover animations and the reveal-on-scroll effect. Replace with your content.
    </p>
    <div class="cards">
      <div class="card reveal">
        <div class="accent"></div>
        <h3 style="margin-top:0">Neon Accents</h3>
        <p style="color:var(--muted)">Cyan and violet glows establish a crisp, high-contrast atmosphere without clutter.</p>
      </div>
      <div class="card reveal">
        <div class="accent"></div>
        <h3 style="margin-top:0">Floating Geometry</h3>
        <p style="color:var(--muted)">Wireframe shapes rotate with depth and parallax, elevating the ultra-modern vibe.</p>
      </div>
      <div class="card reveal">
        <div class="accent"></div>
        <h3 style="margin-top:0">Delightful Micro-interactions</h3>
        <p style="color:var(--muted)">Buttons and surfaces respond cleanly on hover, with tasteful motion and glow.</p>
      </div>
    </div>
  </section>

<script>
/* ===============================
   3D Wireframes Canvas Background
   =============================== */
(() => {
  const canvas = document.getElementById('bg');
  const ctx = canvas.getContext('2d', { alpha: true });

  let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let w = 0, h = 0, cx = 0, cy = 0;
  let last = 0;
  let prefersReducedMotion = false;

  const styles = {
    neonA: getComputedStyle(document.documentElement).getPropertyValue('--neon-a').trim() || '#00d9ff',
    neonB: getComputedStyle(document.documentElement).getPropertyValue('--neon-b').trim() || '#7c3fff',
  };

  // Simple 3D vector helpers and matrices
  const rotateX = (p, a) => {
    const s = Math.sin(a), c = Math.cos(a);
    return { x: p.x, y: p.y*c - p.z*s, z: p.y*s + p.z*c };
  };
  const rotateY = (p, a) => {
    const s = Math.sin(a), c = Math.cos(a);
    return { x: p.z*s + p.x*c, y: p.y, z: p.z*c - p.x*s };
  };
  const rotateZ = (p, a) => {
    const s = Math.sin(a), c = Math.cos(a);
    return { x: p.x*c - p.y*s, y: p.x*s + p.y*c, z: p.z };
  };

  // Geometries
  const geom = {
    cube(size=1){
      const s = size;
      const v = [
        {x:-s,y:-s,z:-s},{x:s,y:-s,z:-s},{x:s,y:s,z:-s},{x:-s,y:s,z:-s},
        {x:-s,y:-s,z:s},{x:s,y:-s,z:s},{x:s,y:s,z:s},{x:-s,y:s,z:s}
      ];
      const e = [
        [0,1],[1,2],[2,3],[3,0],
        [4,5],[5,6],[6,7],[7,4],
        [0,4],[1,5],[2,6],[3,7]
      ];
      return {v,e};
    },
    tetra(size=1){
      const s = size;
      const v = [
        {x: 0, y: s, z: 0},
        {x: 0.943*s, y: -s/3, z: 0},
        {x: -0.471*s, y: -s/3, z: 0.816*s},
        {x: -0.471*s, y: -s/3, z: -0.816*s}
      ];
      const e = [[0,1],[0,2],[0,3],[1,2],[2,3],[3,1]];
      return {v,e};
    },
    octa(size=1){
      const s = size;
      const v = [
        {x: 0, y: s, z: 0},
        {x: 0, y:-s, z: 0},
        {x: s, y: 0, z: 0},
        {x:-s, y: 0, z: 0},
        {x: 0, y: 0, z: s},
        {x: 0, y: 0, z:-s}
      ];
      const e = [
        [0,2],[0,3],[0,4],[0,5],
        [1,2],[1,3],[1,4],[1,5],
        [2,4],[2,5],[3,4],[3,5]
      ];
      return {v,e};
    }
  };

  // Shape object
  class WireShape {
    constructor({type='cube', size=1, color='#00ffff', x=0, y=0, z=8, rot={x:0,y:0,z:0}, rotSpeed={x:0.001,y:0.0012,z:0.0007}, floatAmp=0.25, floatSpeed=0.0008, jitter=0.0}) {
      this.type = type;
      this.g = geom[type](size);
      this.color = color;
      this.base = { x, y, z };
      this.rot = {...rot};
      this.rotSpeed = {...rotSpeed};
      this.floatAmp = floatAmp;
      this.floatSpeed = floatSpeed;
      this.jitter = jitter;
      this.t = Math.random() * 10000;
      this.parallax = 0.0;
      this.lineWidth = 1.25;
    }
    update(dt, ms, tilt){
      this.t += dt;
      // Rotation
      this.rot.x += this.rotSpeed.x * dt * (1 + this.parallax*0.6);
      this.rot.y += this.rotSpeed.y * dt * (1 + this.parallax*0.6);
      this.rot.z += this.rotSpeed.z * dt * (1 + this.parallax*0.6);

      // Parallax influence based on pointer
      this.parallax = Math.hypot(tilt.x, tilt.y);
      this.rollX = tilt.y * 0.35;
      this.rollY = tilt.x * 0.35;
    }
    draw(ctx, fov){
      const floatY = Math.sin(this.t * this.floatSpeed) * this.floatAmp;
      const pos = { x: this.base.x, y: this.base.y + floatY, z: this.base.z };
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.shadowColor = this.color;
      ctx.shadowBlur = 16;
      ctx.strokeStyle = this.color;
      ctx.lineWidth = this.lineWidth * dpr;

      for(const [a,b] of this.g.e){
        const va = this.transform(this.g.v[a], pos);
        const vb = this.transform(this.g.v[b], pos);
        const pa = this.project(va, fov);
        const pb = this.project(vb, fov);
        if (!pa || !pb) continue;
        ctx.beginPath();
        ctx.moveTo(pa.x, pa.y);
        ctx.lineTo(pb.x, pb.y);
        ctx.stroke();
      }

      ctx.restore();
    }
    transform(p, pos){
      let v = p;
      v = rotateX(v, this.rot.x + this.rollX);
      v = rotateY(v, this.rot.y + this.rollY);
      v = rotateZ(v, this.rot.z);
      return { x: v.x + pos.x, y: v.y + pos.y, z: v.z + pos.z };
    }
    project(p, fov){
      const z = p.z;
      const perspective = fov / (z <= 0.1 ? 0.1 : z);
      const x = p.x * perspective + cx;
      const y = p.y * perspective + cy;
      if (x < -100 || x > w+100 || y < -100 || y > h+100) return {x,y}; // allow offscreen edges
      return { x, y };
    }
  }

  const shapes = [];
  const pointer = { x: 0, y: 0, tx: 0, ty: 0 }; // target pointer normalized
  const tilt = { x: 0, y: 0 };

  function makeShapes(){
    shapes.length = 0;
    const neonA = styles.neonA;
    const neonB = styles.neonB;

    // Position scaling based on aspect
    const xs = Math.min(4.2, (w / h) * 3.2);

    shapes.push(new WireShape({
      type: 'cube', size: 1.2, color: neonA,
      x: -xs*0.55, y: -0.4, z: 8.5,
      rot: {x: 0.6, y: -0.3, z: 0.2},
      rotSpeed: {x: 0.0006, y: 0.0011, z: 0.0005},
      floatAmp: 0.35, floatSpeed: 0.0009
    }));
    shapes.push(new WireShape({
      type: 'octa', size: 1.35, color: neonB,
      x: xs*0.65, y: 0.6, z: 10.5,
      rot: {x: -0.2, y: 0.3, z: -0.1},
      rotSpeed: {x: 0.0009, y: 0.0007, z: 0.0005},
      floatAmp: 0.45, floatSpeed: 0.0007
    }));
    shapes.push(new WireShape({
      type: 'tetra', size: 1.1, color: neonA,
      x: xs*0.1, y: -1.0, z: 7.8,
      rot: {x: 0.2, y: 0.2, z: 0.2},
      rotSpeed: {x: 0.0011, y: 0.0009, z: 0.0008},
      floatAmp: 0.28, floatSpeed: 0.0012
    }));
    shapes.push(new WireShape({
      type: 'cube', size: 0.75, color: neonB,
      x: -xs*0.1, y: 1.1, z: 9.6,
      rot: {x: -0.6, y: 0.7, z: 0.1},
      rotSpeed: {x: 0.0008, y: 0.0012, z: 0.0004},
      floatAmp: 0.32, floatSpeed: 0.00085
    }));
  }

  function resize(){
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    w = Math.floor(rect.width);
    h = Math.floor(rect.height);
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    cx = w / 2;
    cy = h / 2;
    makeShapes();
    // Fill initial
    ctx.clearRect(0,0,w,h);
  }

  function render(ms){
    if (!last) last = ms;
    const dt = ms - last;
    last = ms;

    // Ease pointer tilt
    tilt.x += (pointer.tx - tilt.x) * 0.08;
    tilt.y += (pointer.ty - tilt.y) * 0.08;

    // Clear with slight alpha for a smooth fade
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = 'rgba(6, 10, 19, 0.25)';
    ctx.fillRect(0, 0, w, h);

    // Star-like faint dots
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    for(let i=0;i<20;i++){
      const x = (Math.sin(ms*0.0003 + i)*.5+.5) * w;
      const y = (Math.cos(ms*0.0002 + i)*.5+.5) * h;
      ctx.beginPath(); ctx.arc(x, y, 0.6, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();

    // Perspective
    const fov = Math.min(w, h) * 0.9;

    // Update & draw shapes
    for(const s of shapes){
      s.update(prefersReducedMotion ? 0 : dt, ms, tilt);
      s.draw(ctx, fov);
    }

    if (!prefersReducedMotion) requestAnimationFrame(render);
  }

  function onPointerMove(e){
    const rect = canvas.getBoundingClientRect();
    const x = ('touches' in e) ? e.touches[0].clientX : e.clientX;
    const y = ('touches' in e) ? e.touches[0].clientY : e.clientY;
    pointer.tx = ((x - rect.left) / rect.width - 0.5) * 2;  // -1..1
    pointer.ty = ((y - rect.top) / rect.height - 0.5) * 2;
  }
  function onPointerLeave(){
    pointer.tx = 0; pointer.ty = 0;
  }

  // Init after DOM is ready
  const init = () => {
    prefersReducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    resize();
    if (!prefersReducedMotion) requestAnimationFrame(render);

    window.addEventListener('resize', resize, { passive: true });
    window.addEventListener('pointermove', onPointerMove, { passive: true });
    window.addEventListener('pointerleave', onPointerLeave, { passive: true });
    window.addEventListener('touchmove', onPointerMove, { passive: true });
    window.addEventListener('touchend', onPointerLeave, { passive: true });
  };

  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(init, 0);
  } else {
    document.addEventListener('DOMContentLoaded', init);
  }
})();

/* ======================
   Reveal on Scroll Fade
   ====================== */
(() => {
  const revealEls = Array.from(document.querySelectorAll('.reveal'));
  const nav = document.querySelector('header.nav');
  const io = new IntersectionObserver((entries) => {
    for(const e of entries){
      if (e.isIntersecting) {
        e.target.classList.add('in');
        io.unobserve(e.target);
      }
    }
  }, { threshold: 0.12 });

  revealEls.forEach(el => io.observe(el));

  // Hover glow following mouse on cards
  document.querySelectorAll('.card').forEach(card => {
    card.addEventListener('pointermove', (e) => {
      const r = card.getBoundingClientRect();
      const mx = ((e.clientX - r.left) / r.width) * 100;
      const my = ((e.clientY - r.top) / r.height) * 100;
      card.style.setProperty('--mx', mx + '%');
      card.style.setProperty('--my', my + '%');
    }, { passive: true });
  });

  // Elevate nav after scroll a bit
  const onScroll = () => {
    const scrolled = window.scrollY > 6;
    nav.style.boxShadow = scrolled ? '0 10px 30px -20px rgba(0,0,0,.65)' : 'none';
  };
  window.addEventListener('scroll', onScroll, { passive: true });
  onScroll();
})();
</script>
</body>
</html>